// main.cpp (XFlowAI root)
#include <iostream>
#include <thread>
#include <chrono>
#include <vector>
#include <curl/curl.h>
#include <pcap.h>
#include "C++_sniffers/sniffer.h"      // from C++_sniffers
#include "C++_sniffers/packet_handler.h"
#include "Data_Analyzers/Read_Data.h"    // from Data_Analyzers
#include "Data_Analyzers/acall.h"        // from Data_Analyzers

using namespace std;
using namespace CSV2JSON;  // for read_data utilities
using json = nlohmann::json;

// ---------- Sniffer thread ----------
void runSniffer() {
    sniffer sn;
    sn.sniff_packets();  // continuously logs CSV in real-time
}

// ---------- Analyzer thread ----------
void runAnalyzer(const string& lowCSV, const string& flowCSV, CURL* curl) {
    size_t lastIndex = 0;
    while (true) {
        // Tail new rows since lastIndex
        vector<json> newRows = tailMergeCSV(lowCSV, flowCSV, lastIndex);

        if (!newRows.empty()) {
            // Feed LLM
            feedLLM(newRows, curl);

            // Persist NDJSON for later use
            writeJSONToFile(newRows, "merged_output.ndjson", false);
        }

        // Small delay for real-time polling
        this_thread::sleep_for(chrono::milliseconds(200));
    }
}

int main() {
    cout << "=== XFlowAI: Real-time Packet Capture + LLM ===\n";

    // Initialize CURL for LLM once
    CURL* curl;
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    if (!curl) {
        cerr << "CURL initialization failed!" << endl;
        return 1;
    }

    // File paths for CSVs generated by sniffer
    string lowCSV  = "C:/Harshvardhan's_codes/XFlowAI/low.csv";
    string flowCSV = "C:/Harshvardhan's_codes/XFlowAI/flow_app.csv";

    // Launch sniffer in a separate thread
    thread snifferThread(runSniffer);

    // Launch analyzer in main thread (or you can also thread it)
    runAnalyzer(lowCSV, flowCSV, curl);

    // Join sniffer thread before exit (program normally runs infinitely)
    snifferThread.join();

    // Cleanup CURL
    curl_easy_cleanup(curl);
    curl_global_cleanup();
    return 0;
}
